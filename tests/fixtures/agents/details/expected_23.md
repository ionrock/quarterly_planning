---
id: "test-023"
title: "API Documentation Generator"
state: draft
created_at: "2026-01-15T10:00:00Z"
updated_at: "2026-01-15T10:00:00Z"
---

## Overview

Build a tool that generates API documentation from OpenAPI/Swagger specs. Produces a static HTML site with interactive examples, search, and dark mode. Written in TypeScript.

## Constraints

- Support OpenAPI 3.0 and 3.1
- Generated site must work offline

## Implementation Notes

### Technology Stack
- **Language:** TypeScript 5.x
- **Parser:** @apidevtools/swagger-parser
- **Build:** Vite for static site generation
- **Search:** Fuse.js for client-side fuzzy search
- **Styling:** Tailwind CSS with dark mode

### Build Pipeline
```typescript
// build.ts
import SwaggerParser from '@apidevtools/swagger-parser';
import { OpenAPI } from 'openapi-types';
import Handlebars from 'handlebars';
import Fuse from 'fuse.js';

interface BuildConfig {
  specPath: string;
  outputDir: string;
  title?: string;
  theme?: 'light' | 'dark' | 'auto';
}

async function build(config: BuildConfig): Promise<void> {
  // Parse and validate spec
  const spec = await SwaggerParser.validate(config.specPath) as OpenAPI.Document;

  // Extract documentation data
  const docData = extractDocData(spec);

  // Build search index
  const searchIndex = buildSearchIndex(docData);

  // Render HTML pages
  await renderPages(docData, config);

  // Copy static assets
  await copyAssets(config.outputDir);

  // Write search index
  await writeFile(
    `${config.outputDir}/search-index.json`,
    JSON.stringify(searchIndex)
  );
}
```

### Documentation Data Model
```typescript
interface DocData {
  info: {
    title: string;
    version: string;
    description?: string;
  };
  servers: Server[];
  tags: Tag[];
  operations: Operation[];
  schemas: Schema[];
}

interface Operation {
  id: string;
  method: 'get' | 'post' | 'put' | 'delete' | 'patch';
  path: string;
  summary: string;
  description?: string;
  tags: string[];
  parameters: Parameter[];
  requestBody?: RequestBody;
  responses: Response[];
  security: SecurityRequirement[];
  deprecated: boolean;
}

interface Schema {
  name: string;
  type: string;
  properties: Property[];
  required: string[];
  example?: unknown;
}
```

### HTML Template Structure
```handlebars
<!-- templates/operation.hbs -->
<article class="operation" id="{{id}}" data-method="{{method}}">
  <header class="operation-header">
    <span class="method method-{{method}}">{{upper method}}</span>
    <code class="path">{{path}}</code>
    {{#if deprecated}}<span class="badge deprecated">Deprecated</span>{{/if}}
  </header>

  <h3>{{summary}}</h3>
  {{#if description}}<p class="description">{{{markdown description}}}</p>{{/if}}

  {{#if parameters.length}}
  <section class="parameters">
    <h4>Parameters</h4>
    <table>
      <thead><tr><th>Name</th><th>In</th><th>Type</th><th>Required</th><th>Description</th></tr></thead>
      <tbody>
        {{#each parameters}}
        <tr>
          <td><code>{{name}}</code></td>
          <td>{{in}}</td>
          <td><code>{{schema.type}}</code></td>
          <td>{{#if required}}âœ“{{/if}}</td>
          <td>{{description}}</td>
        </tr>
        {{/each}}
      </tbody>
    </table>
  </section>
  {{/if}}

  {{#if requestBody}}
  <section class="request-body">
    <h4>Request Body</h4>
    {{> schema schema=requestBody.schema }}
    {{#if requestBody.example}}
    <pre><code class="language-json">{{json requestBody.example}}</code></pre>
    {{/if}}
  </section>
  {{/if}}

  <section class="responses">
    <h4>Responses</h4>
    {{#each responses}}
    <details {{#if (eq statusCode "200")}}open{{/if}}>
      <summary>
        <span class="status-code status-{{statusClass}}">{{statusCode}}</span>
        {{description}}
      </summary>
      {{#if schema}}{{> schema schema=schema }}{{/if}}
      {{#if example}}<pre><code class="language-json">{{json example}}</code></pre>{{/if}}
    </details>
    {{/each}}
  </section>

  <section class="try-it">
    <h4>Try it out</h4>
    <form class="try-it-form" data-operation="{{id}}">
      <!-- Dynamic form fields generated by JS -->
      <button type="submit">Send Request</button>
    </form>
    <pre class="response-output" hidden></pre>
  </section>
</article>
```

### Client-Side Search
```typescript
// search.ts
import Fuse from 'fuse.js';

interface SearchItem {
  id: string;
  title: string;
  method: string;
  path: string;
  tags: string[];
  description: string;
}

let fuse: Fuse<SearchItem>;

async function initSearch(): Promise<void> {
  const response = await fetch('/search-index.json');
  const items: SearchItem[] = await response.json();

  fuse = new Fuse(items, {
    keys: [
      { name: 'title', weight: 0.4 },
      { name: 'path', weight: 0.3 },
      { name: 'description', weight: 0.2 },
      { name: 'tags', weight: 0.1 },
    ],
    threshold: 0.3,
    includeMatches: true,
  });
}

function search(query: string): SearchResult[] {
  return fuse.search(query).slice(0, 10).map(result => ({
    id: result.item.id,
    title: result.item.title,
    method: result.item.method,
    path: result.item.path,
    matches: result.matches,
  }));
}
```

### Try-It-Out Component
```typescript
// try-it.ts
async function sendRequest(form: HTMLFormElement): Promise<void> {
  const operationId = form.dataset.operation;
  const operation = operations.get(operationId);

  // Build URL with path parameters
  let url = operation.path;
  const formData = new FormData(form);

  for (const param of operation.parameters.filter(p => p.in === 'path')) {
    url = url.replace(`{${param.name}}`, formData.get(param.name) as string);
  }

  // Add query parameters
  const queryParams = new URLSearchParams();
  for (const param of operation.parameters.filter(p => p.in === 'query')) {
    const value = formData.get(param.name);
    if (value) queryParams.set(param.name, value as string);
  }
  if (queryParams.toString()) url += `?${queryParams}`;

  // Build headers
  const headers: Record<string, string> = {};
  for (const param of operation.parameters.filter(p => p.in === 'header')) {
    const value = formData.get(param.name);
    if (value) headers[param.name] = value as string;
  }

  // Build request body
  let body: string | undefined;
  if (operation.requestBody) {
    body = formData.get('requestBody') as string;
    headers['Content-Type'] = 'application/json';
  }

  const response = await fetch(url, {
    method: operation.method.toUpperCase(),
    headers,
    body,
  });

  displayResponse(form, response);
}
```

## Review Notes

(none yet)

## Tickets

### Ticket 1: Spec Parser

**Summary:** Parse and validate OpenAPI specifications.

**Definition of Done:** Valid specs are parsed, invalid ones error clearly.

### Ticket 2: HTML Generator

**Summary:** Generate static HTML documentation.

**Definition of Done:** Documentation renders correctly in browsers.

### Ticket 3: Interactive Features

**Summary:** Add search and try-it-out functionality.

**Definition of Done:** Users can search and make test requests.
